# TypeScript Mastery: 500 Problems for Perfection

### Introduction & Basics

- [ ] 1. What is TypeScript and how does it differ from JavaScript?
- [ ] 2. Explain the concept of "Static Typing" vs "Dynamic Typing". Which one does TS use?
- [ ] 3. How does the TypeScript compiler (tsc) work? What is "transpilation"?
- [ ] 4. What is the command to install TypeScript globally?
- [ ] 5. How do you compile a single TypeScript file named `index.ts` from the command line?
- [ ] 6. What feature of TypeScript allows it to infer types when they are not explicitly annotated?
- [ ] 7. Identify the type inferred for `let count = 0;`. Cons can you assign a string to it later?
- [ ] 8. What are the primitive types available in TypeScript? List them all.
- [ ] 9. How do you explicitly annotate a variable as a number? Provide syntax.
- [ ] 10. What is the `any` type in TypeScript? When should you use it (or avoid it)?
- [ ] 11. What is the `unknown` type? How is it different from `any`?
- [ ] 12. Explain the `void` type. Where is it commonly used?
- [ ] 13. What is the difference between `null` and `undefined` in TypeScript?
- [ ] 14. How does `strictNullChecks` affect how `null` and `undefined` function?
- [ ] 15. What is the `never` type? Give a concrete example of a function that returns `never`.
- [ ] 16. Explain the concept of Type Annotation in functions (parameters and return type).
- [ ] 17. Write a function `add` that takes two numbers and returns their sum, with full type annotations.
- [ ] 18. What are "Union Types"? How do you denote them?
- [ ] 19. Write a type annotation for a variable that can be either a `string` or a `number`.
- [ ] 20. What is "Type Narrowing"? Give an example using `typeof`.
- [ ] 21. What are "Literal Types"? How can you enforce a variable to only hold the specific string "success" or "error"?
- [ ] 22. What are "Type Aliases"? Syntax to create one?
- [ ] 23. Create a type alias `UserID` that can be a string or number.
- [ ] 24. What is the difference between `type` and `interface` (basics)?
- [ ] 25. How do you define an Object Type using an inline type annotation?
- [ ] 26. How do you define an Object Type using a Type Alias?
- [ ] 27. How do you mark an object property as optional?
- [ ] 28. What happens if you try to access a property that doesn't exist on a typed object?
- [ ] 29. How do you make a property "read-only" in an object type?
- [ ] 30. What are "Intersection Types"? How do they differ from Union Types?
- [ ] 31. Syntax for Intersection Types (`&`).
- [ ] 32. Can you combine Union and Intersection types? If so, what is the precedence?
- [ ] 33. What are Arrays in TypeScript? Two ways to type them (syntax).
- [ ] 34. How do you define an array of strings?
- [ ] 35. What is a "Tuple"? How is it different from an Array?
- [ ] 36. Define a tuple that contains exactly one string followed by one number.
- [ ] 37. Can you push new elements to a fixed-size Tuple in TypeScript? (Trick question).
- [ ] 38. What is the `readonly` modifier for Arrays and Tuples?
- [ ] 39. What are Enums? Syntax for defining a numeric Enum.
- [ ] 40. How do numeric Enums auto-increment?
- [ ] 41. What are String Enums?
- [ ] 42. What are "Heterogeneous Enums"? Are they recommended?
- [ ] 43. What is a "Const Enum"? How does it differ in compilation?
- [ ] 44. What key feature differentiates TypeScript Enums from most other TS features regarding runtime code?
- [ ] 45. What is "Type Assertion" (casting)? Two syntaxes for it (`as` and `<>`).
- [ ] 46. When would you need to use Type Assertion?
- [ ] 47. Is Type Assertion distinct from casting in languages like C# or Java? Does it perform runtime checks?
- [ ] 48. What is "const assertion" (`as const`)? What does it do to an object literal?
- [ ] 49. How does `as const` affect arrays?
- [ ] 50. Explain "Function Overloading" in TypeScript.
- [ ] 51. What is the "Implementation Signature" in function overloading? Is it visible to the caller?
- [ ] 52. Can you have multiple implementation signatures?
- [ ] 53. What is the `object` type (lowercase) vs `Object` type (uppercase) vs `{}`?
- [ ] 54. What are "Rest Parameters" in functions? How do you type them?
- [ ] 55. What is the `this` parameter in TypeScript function definitions? Where must it be placed?
- [ ] 56. Analyze this code:
```ts
function fail(msg: string): never {
  throw new Error(msg);
} 
```
Is this correct usage of `never`?
- [ ] 57. Analyze this code:
```ts
let x: unknown = "hello";
let y: string = x;
```
Will this compile? Why or why not?
- [ ] 58. Fix the code from #57 using Type Assertion.
- [ ] 59. Fix the code from #57 using Type Narrowing.
- [ ] 60. How do you allow a function parameter to be `undefined`?
- [ ] 61. What are "Optional Parameters" in functions? Syntax?
- [ ] 62. Can a required parameter follow an optional parameter?
- [ ] 63. How do default parameters interact with type inference?
- [ ] 64. What is the `BigInt` type in TypeScript?
- [ ] 65. What is the `symbol` type in TypeScript?
- [ ] 66. How do you create a unique symbol type?
- [ ] 67. Explain Structural Typing vs Nominal Typing. Which does TS use?
- [ ] 68. If Interface A has properties `{ x: number }` and Interface B has `{ x: number, y: number }`, can B be assigned to A?
- [ ] 69. Can A be assigned to B (from Q68)?
- [ ] 70. What is "Excess Property Checking"? When does it happen?
- [ ] 71. How to bypass Excess Property Checking? (3 ways).
- [ ] 72. What acts as the "top type" in TypeScript?
- [ ] 73. What acts as the "bottom type" in TypeScript?
- [ ] 74. Is `void` a subtype of `undefined`?
- [ ] 75. Is `undefined` a subtype of `void`?
- [ ] 76. Can you assign `null` to a variable of type `number` if `strictNullChecks` is off?
- [ ] 77. Can you assign `null` to a variable of type `number` if `strictNullChecks` is on?
- [ ] 78. What is the Non-null assertion operator (`!`)?
- [ ] 79. When should you use the `!` operator?
- [ ] 80. What are "Ambient Contexts"?
- [ ] 81. What is a `.d.ts` file?
- [ ] 82. What is `declare var`?
- [ ] 83. Difference between `tsc` and `ts-node`.
- [ ] 84. How to initialize a `tsconfig.json` file?
- [ ] 85. What is the `target` option in `tsconfig.json`?
- [ ] 86. What is the `module` option in `tsconfig.json`?
- [ ] 87. What does `lib` option configure?
- [ ] 88. Explain `noImplicitAny`.
- [ ] 89. Explain `strict` mode in `tsconfig.json`. What flags does it enable?
- [ ] 90. What is `rootDir` and `outDir`?
- [ ] 91. How to exclude files from compilation?
- [ ] 92. What is `include` array in `tsconfig`?
- [ ] 93. What is syntax for a Single Line Comment vs Multi Line Comment in TS? (Same as JS).
- [ ] 94. Does TypeScript code exist at runtime?
- [ ] 95. What are "Index Signatures"?
- [ ] 96. Syntax for an object that can have any string key and number value.
- [ ] 97. Can you have multiple index signatures?
- [ ] 98. Can index signature keys be anything other than string or number?
- [ ] 99. Type this: An array of functions that each take a string and return void.
- [ ] 100. Type this: An object where keys are UserIDs (numbers) and values are User objects.

### Interfaces & Classes

- [ ] 101. Define an interface `Car` with properties `make`, `model`, and optional `year`.
- [ ] 102. How do you extend an interface? Syntax?
- [ ] 103. Can an interface extend multiple interfaces?
- [ ] 104. Can an interface extend a Class?
- [ ] 105. Difference between `interface` and `type` regarding "Declaration Merging".
- [ ] 106. Demonstrate Declaration Merging with an example.
- [ ] 107. Can types implement interfaces?
- [ ] 108. Syntax for a class implementing an interface.
- [ ] 109. Can a class implement multiple interfaces?
- [ ] 110. What are Access Modifiers in Classes? List them.
- [ ] 111. What is `public` (default)?
- [ ] 112. What is `private`? Is it private at runtime?
- [ ] 113. What is `#private` (JS private fields) vs `private` (TS modifier)?
- [ ] 114. What is `protected`?
- [ ] 115. What are "Parameter Properties" in constructors? Syntax?
- [ ] 116. How to define a `readonly` property in a class?
- [ ] 117. What are Getters and Setters in TS classes?
- [ ] 118. Can a Setter have a different type than the Getter?
- [ ] 119. What is an Abstract Class?
- [ ] 120. Can you instantiate an abstract class?
- [ ] 121. What is an Abstract Method?
- [ ] 122. Must concrete subclasses implement all abstract methods?
- [ ] 123. Can an Interface define a constructor signature?
- [ ] 124. How to type "Static" properties/methods?
- [ ] 125. Are static members inherited?
- [ ] 126. What is the `this` type in classes (polymorphic this)?
- [ ] 127. Explain `implements` vs `extends`.
- [ ] 128. Can you override methods in TS?
- [ ] 129. What is the `override` keyword? Why is it useful?
- [ ] 130. What is `super`?
- [ ] 131. If a child class has a constructor, must it call `super()`?
- [ ] 132. Can you modify `public` properties via a subclass?
- [ ] 133. Difference between an Interface and an Abstract Class.
- [ ] 134. Create a Singleton class in TypeScript.
- [ ] 135. How to prevent inheritance of a class? (Is there a `final` keyword?)
- [ ] 136. What is the type of a Class Constructor itself?
- [ ] 137. How to define an interface for a Function?
- [ ] 138. How to define an interface for a Class Constructor (the "Static Side")?
- [ ] 139. Explain structural typing with classes with private properties. (Do they compatible if structure is same?)
- [ ] 140. What is strict property initialization in classes?
- [ ] 141. How to use the definite assignment assertion operator (`!`) in class properties.
- [ ] 142. Define a generic class `Box<T>`.
- [ ] 143. How to constraint a generic type in a class?
- [ ] 144. Can a static member use the class's generic type parameter `T`? Why not?
- [ ] 145. Mixins in TypeScript: General concept.
- [ ] 146. Syntax for a simple Mixin function.
- [ ] 147. What is `InstanceType<T>` utility?
- [ ] 148. Using a class as an injection token.
- [ ] 149. Difference between `typeof ClassName` and `ClassName`.
- [ ] 150. Code Challenge: Write a class `Bank` with `private _balance`. Add methods `deposit` and `withdraw`. Ensure `withdraw` throws error if insufficient funds.

### Generics

- [ ] 151. What are Generics? Why do we use them?
- [ ] 152. Write a generic identity function that returns whatever is passed to it.
- [ ] 153. What is the convention for naming generic type parameters (e.g., T, U, V)?
- [ ] 154. How to pass multiple type arguments to a generic?
- [ ] 155. Type inference with generics: Do you always need to specify `<number>`?
- [ ] 156. Constraints: How to ensure `T` has a `.length` property?
- [ ] 157. Syntax: `function foo<T extends { length: number }>(arg: T)`
- [ ] 158. Use `keyof` in a generic constraint.
- [ ] 159. Write a function `getProperty<T, K extends keyof T>(obj: T, key: K)`.
- [ ] 160. What are Default Type Parameters in generics?
- [ ] 161. Syntax for default generic type: `<T = string>`.
- [ ] 162. Generic Classes vs Generic Interfaces.
- [ ] 163. Can we have generic Enums?
- [ ] 164. Generic Type Aliases.
- [ ] 165. Usage of `Array<T>` vs `T[]`.
- [ ] 166. `Promise<T>`: What does it represent?
- [ ] 167. How to type an async function's return value?
- [ ] 168. Recursive generics (e.g., a Tree node).
- [ ] 169. Analyze `type OrNull<Type> = Type | null;`.
- [ ] 170. What is "Generic Parameter Defaults"?
- [ ] 171. When are generic types instantiated?
- [ ] 172. Can you constrain a generic to be a constructor?
- [ ] 173. What is the `NonNullable<T>` utility type?
- [ ] 174. Challenge: Write a Generic Stack class (push, pop, peek).
- [ ] 175. Variance: Covariance vs Contravariance in Generics (Advanced).
- [ ] 176. Why is function parameter type bivariant (historically) or contravariant?
- [ ] 177. How does TS handle generic instantiation inside a function body?
- [ ] 178. `Record<K, T>` utility type explanation.
- [ ] 179. `Partial<T>` utility type explanation.
- [ ] 180. `Required<T>` utility type explanation.
- [ ] 181. `Readonly<T>` utility type explanation.
- [ ] 182. `Pick<T, K>` utility type explanation.
- [ ] 183. `Omit<T, K>` utility type explanation.
- [ ] 184. `Exclude<T, U>` utility type explanation.
- [ ] 185. `Extract<T, U>` utility type explanation.
- [ ] 186. `ReturnType<T>` utility type explanation.
- [ ] 187. `Parameters<T>` utility type explanation.
- [ ] 188. `ConstructorParameters<T>` utility type explanation.
- [ ] 189. `Awaited<T>` utility type explanation.
- [ ] 190. How to create a custom utility type `MyPick<T, K>`?
- [ ] 191. How to create `Nullable<T>`?
- [ ] 192. Explain `type DeepPartial<T>`.
- [ ] 193. Challenge: Implement `DeepReadonly<T>`.
- [ ] 194. What is the `ThisType<T>` utility?
- [ ] 195. How generics interact with Union types (Distributive Conditional Types).
- [ ] 196. Prevent distribution/splitting in conditional types: `[T] extends [U]`.
- [ ] 197. Generic arrow function syntax in `.tsx` files (Conflict with JSX).
- [ ] 198. How to fix `<T>` being interpreted as a tag in JSX? (Use `<T,>`).
- [ ] 199. Generic Constraints with `new` keyword.
- [ ] 200. Inference of generic types from arguments.

### Advanced Types & Manipulation

- [ ] 201. What is the `keyof` operator?
- [ ] 202. What does `keyof any` return?
- [ ] 203. `typeof` operator in Type context vs Value context.
- [ ] 204. `ReturnType<typeof func>` pattern.
- [ ] 205. Indexed Access Types (`T[K]`).
- [ ] 206. Accessing the type of an array element: `MyArray[number]`.
- [ ] 207. Accessing the type of a specific property: `User["age"]`.
- [ ] 208. What are Conditional Types? (`T extends U ? X : Y`).
- [ ] 209. Nested Conditional Types.
- [ ] 210. What is the `infer` keyword?
- [ ] 211. Usage of `infer` to get the return type of a function.
- [ ] 212. Usage of `infer` to get array element type (`Unpacked`).
- [ ] 213. Distributive Conditional Types explanation.
- [ ] 214. How to filter unions using conditional types (`Exclude`).
- [ ] 215. Mapped Types Syntax (`{ [P in K]: T }`).
- [ ] 216. Use mapped types to make all properties boolean.
- [ ] 217. Modifiers in Mapped Types: `+` and `-` (e.g., `-readonly`, `-?`).
- [ ] 218. Removing optional modifier: `{ [P in K]-?: T[P] }`.
- [ ] 219. Key Remapping via `as`: `{ [P in K as NewKey]: T[P] }`.
- [ ] 220. Template Literal Types.
- [ ] 221. Concatenating strings in types: `` `get${Capitalize<string>}` ``.
- [ ] 222. Intrinsic String Manipulation Types: `Uppercase<S>`, `Lowercase<S>`, `Capitalize<S>`, `Uncapitalize<S>`.
- [ ] 223. Recursive Type Aliases.
- [ ] 224. Typing JSON data (Recursive union).
- [ ] 225. Discriminated Unions (Tagged Unions).
- [ ] 226. What makes a union "Discriminated"?
- [ ] 227. Exhaustiveness handling with `never`.
- [ ] 228. Implementing a `switch` statement that ensures all cases of a discriminated union are handled.
- [ ] 229. Intersection of object types vs Interface extension.
- [ ] 230. Meaning of `type T = {}`.
- [ ] 231. Meaning of `type T = object`.
- [ ] 232. Meaning of `type T = unknown`.
- [ ] 233. How TypeScript determines "Best Common Type".
- [ ] 234. Contextual Typing.
- [ ] 235. What is "Type Widening"?
- [ ] 236. User-Defined Type Guards (`arg is Type`).
- [ ] 237. Write a type guard `isString(val: any): val is string`.
- [ ] 238. Assertion Functions (`asserts condition`).
- [ ] 239. Variadic Tuple Types.
- [ ] 240. Labelled Tuple Elements.
- [ ] 241. Spread features in tuples.
- [ ] 242. Optional tuple elements.
- [ ] 243. Const assertions and tuples.
- [ ] 244. `satisfies` operator (TS 4.9).
- [ ] 245. Difference between `satisfies` and `as`.
- [ ] 246. `satisfies` enables validation without widening.
- [ ] 247. Triple-slash directives (`/// <reference path="..." />`).
- [ ] 248. Module augmentation (`declare module`).
- [ ] 249. Global augmentation (`declare global`).
- [ ] 250. How to extend the `Window` interface globally.

### Modules & Namespaces

- [ ] 251. Difference between "Internal Modules" (Namespaces) and "External Modules" (Modules).
- [ ] 252. Syntax for exporting a namespace.
- [ ] 253. When should you use Namespaces today? (Rarely).
- [ ] 254. ES Modules syntax (`import` / `export`).
- [ ] 255. `default` export vs named exports.
- [ ] 256. `export type` and `import type`.
- [ ] 257. Why use `import type`? (Elision).
- [ ] 258. `export =` and `import = require()` (CommonJS legacy).
- [ ] 259. `esModuleInterop` flag.
- [ ] 260. `allowSyntheticDefaultImports` flag.
- [ ] 261. `isolatedModules` flag.
- [ ] 262. `moduleResolution`: `node` vs `classic`.
- [ ] 263. Path mapping in `tsconfig.json` (`paths`).
- [ ] 264. `baseUrl` configuration.
- [ ] 265. Loading `.json` files in TypeScript (`resolveJsonModule`).
- [ ] 266. Dynamic imports `import()`.
- [ ] 267. Tree Shaking and Modules.
- [ ] 268. Circular dependencies in TS.
- [ ] 269. Barrel files (`index.ts` exporting everything).
- [ ] 270. Type-only imports (TS 3.8).

### TypeScript & React (Or Web)

- [ ] 271. File extension for React components (`.tsx`).
- [ ] 272. Defining Props interface.
- [ ] 273. `React.FC` / `React.FunctionComponent` type.
- [ ] 274. Why is `React.FC` sometimes discouraged? (Implicit children).
- [ ] 275. Typing `children` explicitly.
- [ ] 276. `React.ReactNode` vs `JSX.Element`.
- [ ] 277. Typing `useState<T>`.
- [ ] 278. Typing `useReducer`.
- [ ] 279. Typing `useRef` (Mutable vs Immutable).
- [ ] 280. `useRef<HTMLDivElement>(null)`.
- [ ] 281. Typing Event Handlers (`React.ChangeEvent<HTMLInputElement>`).
- [ ] 282. Typing `onSubmit` in Forms.
- [ ] 283. `ComponentProps<T>` utility.
- [ ] 284. Extending HTML Element props (`HTMLAttributes`).
- [ ] 285. Polymorphic Components (advanced pattern).
- [ ] 286. Typing `forwardRef`.
- [ ] 287. Generics in React Components.
- [ ] 288. `React.Component` vs `React.PureComponent` types.
- [ ] 289. Context API typing.
- [ ] 290. Typing Custom Hooks.
- [ ] 291. CSS Properties typing (`React.CSSProperties`).
- [ ] 292. How to handle `defaultProps` in TS.
- [ ] 293. Type checking for Styled Components or Emotion.
- [ ] 294. Global state management typing (Redux/Zustand basics).
- [ ] 295. Discriminated unions for Redux Actions.
- [ ] 296. Thunks typing.
- [ ] 297. Typing React Router parameters.
- [ ] 298. Error Boundaries typing.
- [ ] 299. Server Components vs Client Components types (Next.js context).
- [ ] 300. Testing React Components with TS.

### Node.js & Backend

- [ ] 301. `ts-node` vs `tsc` + `node` in production.
- [ ] 302. Typing `process.env` in Node.js.
- [ ] 303. Typing Express `Request` and `Response`.
- [ ] 304. Extending Express Request interface (Declaration Merging via global).
- [ ] 305. Typing Middleware functions in Express.
- [ ] 306. Error Handling Middleware typing in Express.
- [ ] 307. Controller typing patterns.
- [ ] 308. TypeORM basics: Defining Entities with Decorators.
- [ ] 309. Prisma basics: How are types generated?
- [ ] 310. NestJS: How it leverages TS Decorators & Reflection.
- [ ] 311. Types for File Uploads (e.g., `Multer.File`).
- [ ] 312. WebSockets / Socket.io events typing.
- [ ] 313. JWT payload typing definition.
- [ ] 314. Passport.js strategies typing strategies.
- [ ] 315. Node.js Streams and Buffer typing.
- [ ] 316. Working with `fs` module promises and types.
- [ ] 317. Child Process typing.
- [ ] 318. Cluster module typing.
- [ ] 319. Worker Threads typing.
- [ ] 320. Strong typing for Event Emitters (`TypedEmitter`).

### Testing types

- [ ] 321. Jest: Typing `describe`, `it`, and `expect` (Globals vs Imported).
- [ ] 322. Typing Mock functions (`jest.Mock` or `jest.MockedFunction`).
- [ ] 323. Mocking modules with types (e.g. `jest.mocked()`).
- [ ] 324. `jest.spyOn` typing and usage.
- [ ] 325. Strategies for testing private methods (Is casting to `any` acceptable?).
- [ ] 326. Snapshot testing types.
- [ ] 327. Vitest compatibility and differences in typing.
- [ ] 328. Cypress / Playwright E2E commands typing.
- [ ] 329. Testing async functions/Promises.
- [ ] 330. Coverage reports terminology.

### Configuration & Tooling

- [ ] 331. ESLint with TypeScript (`@typescript-eslint/parser` and `plugin`).
- [ ] 332. Prettier integration with ESLint.
- [ ] 333. `tsconfig` `paths` alias configuration.
- [ ] 334. Problem with `paths` at runtime? (Difference between tsc and webpack/vite resolution).
- [ ] 335. `composite` projects (Project References) - why use them?
- [ ] 336. `incremental` builds explanation.
- [ ] 337. `ts-loader` vs `babel-loader` for Webpack.
- [ ] 338. `esbuild` speed and limitations (no type checking).
- [ ] 339. `swc` integration.
- [ ] 340. Monorepo setup (Turborepo/Nx) with shared `tsconfig`.

### Design Patterns in TS

- [ ] 341. Singleton Pattern implementation in TS.
- [ ] 342. Factory Pattern with Generics.
- [ ] 343. Observer Pattern with Interfaces.
- [ ] 344. Strategy Pattern.
- [ ] 345. Decorator Pattern (Classic GoF vs TS Decorators).
- [ ] 346. Adapter Pattern.
- [ ] 347. Facade Pattern.
- [ ] 348. Dependency Injection (DI) basics.
- [ ] 349. Inversion of Control (IoC).
- [ ] 350. Builder Pattern with method chaining.

### Ecosystem & Libraries

- [ ] 351. Zod: Defining schemas and inferring types.
- [ ] 352. `z.infer<typeof schema>`.
- [ ] 353. Yup vs Zod vs io-ts.
- [ ] 354. RxJS Observables typing.
- [ ] 355. Redux Toolkit: `createSlice`, `PayloadAction` types.
- [ ] 356. Styled-components `DefaultTheme` declaration merging.
- [ ] 357. GraphQL Code Generator (codegen) - Why it's essential.
- [ ] 358. Apollo Client hooks typing (`useQuery<Data, Vars>`).
- [ ] 359. tRPC basics: Type safety without schemas.
- [ ] 360. TanStack Query (React Query) keys and return types.

### Advanced Concepts & Esoterica

- [ ] 361. Experimental Decorators (`"experimentalDecorators": true`).
- [ ] 362. Stage 3 Decorators (2023 standard) - The future.
- [ ] 363. Metadata Reflection API (`reflect-metadata`).
- [ ] 364. `declare global` augmenting global scope.
- [ ] 365. `dts-gen` tool (generating types from JS).
- [ ] 366. Recursion limits in Conditional Types.
- [ ] 367. Tail-recursion optimization in Types?
- [ ] 368. Variadic Tuples usage.
- [ ] 369. `satisfies` vs `as const` deep dive.
- [ ] 370. `const` Type Parameters (TS 5.0) - `function foo<const T>(arg: T)`.
- [ ] 371. Performance of Enum vs Object as const.
- [ ] 372. `export type *` syntax.
- [ ] 373. `import type` elision and build tools optimization.
- [ ] 374. `verbatimModuleSyntax` flag.
- [ ] 375. `module: nodenext` and ESM resolution handling.
- [ ] 376. Covariance and Contravariance in-depth.
- [ ] 377. Bivariance in method arguments vs function properties.
- [ ] 378. Brand Types (Branded primitives) for nominal typing simulation.
- [ ] 379. Opaque Types.
- [ ] 380. Currying and Partial Application typing.

### Security, Performance & Publishing

- [ ] 381. Formatting package.json `exports` for TS.
- [ ] 382. `main` vs `types` vs `typings`.
- [ ] 383. `prepublishOnly` script usage.
- [ ] 384. Source Maps (`sourceMap` flag) - Security implications?
- [ ] 385. Type Stripping performance cost.
- [ ] 386. Does TypeScript prevent XSS? (No).
- [ ] 387. Does TypeScript prevent SQL Injection? (No).
- [ ] 388. How to type-safe SQL queries (e.g. pg-typed, kysely).
- [ ] 389. `skipLibCheck` flag optimization.
- [ ] 390. `ts-prune` to find unused exports.

### Open Source, Codebases & Analysis

- [ ] 391. How to read TypeScript source code on GitHub.
- [ ] 392. Analyzing a complex generic type from a library (e.g. Redux's `connect`).
- [ ] 393. Contributing to `DefinitelyTyped` (`@types/package`).
- [ ] 394. Workflow for adding missing types to a DT package.
- [ ] 395. Debugging "Type instantiation is excessively deep".
- [ ] 396. Debugging "Type 'X' is not assignable to type 'Y'".
- [ ] 397. Best practices for library authors exposing types.
- [ ] 398. Semantic Versioning for Types (Breaking changes in types).
- [ ] 399. Strategies for Migrating a large JS codebases to TS.
- [ ] 400. "Loose" conversion (allowJs, checkJs) vs "Strict" conversion.
- [ ] 401. Challenge: Analyze the type definition of `Promise.all`.
- [ ] 402. Challenge: Analyze the type definition of `Array.prototype.map`.
- [ ] 403. Challenge: Create a type `Zip<T, U>` that zips two tuples.
- [ ] 404. Challenge: Create a type `CamelCase<S>` using Template Literals.
- [ ] 405. Challenge: Create a type `Join<Array, Separator>`.
- [ ] 406. Challenge: Create a type `DeepMutable<T>`.
- [ ] 407. Challenge: Create a type `Getters<T>` that extracts getters from a class.
- [ ] 408. Challenge: Implement a type-safe `EventEmitter`.
- [ ] 409. Challenge: Implement a type-safe `router` (like Express) using Template Literals.
- [ ] 410. Challenge: Typing a plugin system.
- [ ] 411. How to debug types using VS Code hover?
- [ ] 412. How to use VScode "Go to Type Definition".
- [ ] 413. What is the TypeScript Language Server?
- [ ] 414. How plugins like `ts-plugin-styled-components` work.
- [ ] 415. What is `typescript-eslint`'s role in code analysis?
- [ ] 416. Understanding `lib.d.ts` versions.
- [ ] 417. How to polyfill types for older TS versions.
- [ ] 418. `typesVersions` field in package.json.
- [ ] 419. How to use `tsc --traceResolution`.
- [ ] 420. How to use `tsc --extendedDiagnostics`.
- [ ] 421. `tsc --noEmit`: Checking types without building.
- [ ] 422. `tsc --watch`: Watch mode.
- [ ] 423. `tsc --build`: Build mode for references.
- [ ] 424. Using `JSDoc` to type JS files in a TS project (`allowJs`).
- [ ] 425. `@ts-check` in JS files.
- [ ] 426. Explain `@ts-ignore` vs `@ts-expect-error`.
- [ ] 427. Why prefer `@ts-expect-error`?
- [ ] 428. `@ts-nocheck` usage.
- [ ] 429. Using `// @ts-ignore` for line vs block (trick).
- [ ] 430. Formatting: Prettier vs ESLint for TS.
- [ ] 431. Analysis: How React's `RefObject` is defined.
- [ ] 432. Analysis: How Vue's `ref` is defined.
- [ ] 433. Analysis: How Angular's `Observable` integration works.
- [ ] 434. Analysis: How Svelte's `writable` stores are typed.
- [ ] 435. Analysis: How `zod` handles recursive schemas.
- [ ] 436. Analysis: How `trpc` infers backend types on frontend.
- [ ] 437. Analysis: How `prisma` generates the client client types.
- [ ] 438. Analysis: How `graphql-codegen` maps GQL types to TS.
- [ ] 439. Analysis: How `jest` extends global environment.
- [ ] 440. Analysis: How `styled-components` theming works via declaration merging.
- [ ] 441. Practice: Clone a small TS repo and build it.
- [ ] 442. Practice: Run tests in a TS repo.
- [ ] 443. Practice: Change a type in a library and see what breaks.
- [ ] 444. Practice: Write a definition file (`.d.ts`) for a small untyped JS library.
- [ ] 445. Practice: publish a scoped package `@me/utils` written in TS.
- [ ] 446. Practice: Use `npm link` to test your package locally.
- [ ] 447. Practice: Configure GitHub Actions for TS type checking.
- [ ] 448. Practice: Set up a pre-commit hook (husky) for `tsc`.
- [ ] 449. Practice: Use VS Code debugger with TS source maps.
- [ ] 450. Practice: Debug a TS node process using Chrome DevTools.
- [ ] 451. Advanced: Covariant return types in classes.
- [ ] 452. Advanced: Contravariant arguments in function overloads.
- [ ] 453. Advanced: Why `Promise.all` result is a tuple?
- [ ] 454. Advanced: Why `keyof any` is `string | number | symbol`?
- [ ] 455. Advanced: Why `Object.keys` returns `string[]` not `keyof T[]`?
- [ ] 456. Advanced: Explanation of "Soundness" in TS (Is TS sound?).
- [ ] 457. Advanced: Unsound behaviors used for convenience (e.g. array covariance).
- [ ] 458. Advanced: Void function assignability.
- [ ] 459. Advanced: Class property initialization strictness.
- [ ] 460. Advanced: `exactOptionalPropertyTypes` (TS 4.4).
- [ ] 461. Advanced: `noPropertyAccessFromIndexSignature` (TS 4.2).
- [ ] 462. Advanced: `noUncheckedIndexedAccess`.
- [ ] 463. Advanced: `useUnknownInCatchVariables` (TS 4.4).
- [ ] 464. Advanced: `preserveValueImports` (TS 4.5).
- [ ] 465. Advanced: `allowArbitraryExtensions` (TS 5.0).
- [ ] 466. Advanced: `customConditions`.
- [ ] 467. Advanced: `resolvePackageJsonExports`.
- [ ] 468. Advanced: `resolvePackageJsonImports`.
- [ ] 469. Advanced: `moduleDetection`.
- [ ] 470. Advanced: `api-extractor` from Microsoft.
- [ ] 471. Final Concept: "Type-Level Programming".
- [ ] 472. Final Concept: "Runtime Type Checking" (io-ts/zod).
- [ ] 473. Final Concept: "Nominal Typing" pattern matching.
- [ ] 474. Final Concept: "Higher Kinded Types" (HKT) simulation.
- [ ] 475. Final Concept: "Module Augmentation" for plugins.
- [ ] 476. Project Idea: Build a CLI tool in TS.
- [ ] 477. Project Idea: Build a TS Express API.
- [ ] 478. Project Idea: Build a generic Form component in React+TS.
- [ ] 479. Project Idea: Build a typed Event Emitter library.
- [ ] 480. Project Idea: Build a simple ORM wrapper.
- [ ] 481. Project Idea: Create a "Zod-like" validaion library (simple version).
- [ ] 482. Project Idea: Contribution to an Open Source TS project.
- [ ] 483. Project Idea: Migrate a small JS project to TS.
- [ ] 484. Reflection: What is the biggest benefit of TS in your opinion?
- [ ] 485. Reflection: What is the biggest pain point of TS?
- [ ] 486. Reflection: Do you prefer Types or Interfaces?
- [ ] 487. Reflection: How has TS improved your JS coding?
- [ ] 488. Reflection: Do you use `any`? Be honest.
- [ ] 489. Reflection: How do you handle 3rd party libs without types?
- [ ] 490. Reflection: Thoughts on TS vs JSDoc.
- [ ] 491. Final Boss: Explain `T extends infer U ? U : never`.
- [ ] 492. Final Boss: Explain `(-readonly [P in keyof T]-?: T[P])`.
- [ ] 493. Final Boss: Write a type to parse a URL string parameters.
- [ ] 494. Final Boss: Write a type to parse JSON string (conceptually).
- [ ] 495. Final Boss: Implement a type-safe `pipe` function.
- [ ] 496. Final Boss: Implement a type-safe `compose` function.
- [ ] 497. Final Boss: Implement `Curry<F>` type.
- [ ] 498. Final Boss: Creating a recursive immutable type.
- [ ] 499. Final Boss: The "Halting Problem" in TS Type System.
- [ ] 500. Congratulations! You have completed the list. Mark this done.

