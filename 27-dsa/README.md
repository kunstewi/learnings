# Data Structures and Algorithms - Comprehensive Question Bank (1000 Questions)

## Table of Contents
1. [Complexity Analysis (30)](#complexity-analysis)
2. [Arrays (60)](#arrays)
3. [Strings (60)](#strings)
4. [Linked Lists (40)](#linked-lists)
5. [Stacks (30)](#stacks)
6. [Queues (20)](#queues)
7. [Hash Tables (30)](#hash-tables)
8. [Trees (90)](#trees)
9. [Heaps (30)](#heaps)
10. [Graphs (60)](#graphs)
11. [Sorting Algorithms (40)](#sorting-algorithms)
12. [Searching Algorithms (30)](#searching-algorithms)
13. [Recursion (30)](#recursion)
14. [Dynamic Programming (80)](#dynamic-programming)
15. [Greedy Algorithms (30)](#greedy-algorithms)
16. [Backtracking (30)](#backtracking)
17. [Bit Manipulation (40)](#bit-manipulation)
18. [Mathematical Algorithms (50)](#mathematical-algorithms)
19. [Advanced Topics (270)](#advanced-topics)

---

## Complexity Analysis

- [ ] 1. What is time complexity? Explain with examples.
- [ ] 2. What is space complexity? How is it different from time complexity?
- [ ] 3. Explain Big O notation. What does O(n) mean?
- [ ] 4. What is the difference between O(n), Î˜(n), and Î©(n)?
- [ ] 5. Explain O(1) constant time complexity with examples.
- [ ] 6. What is O(log n) complexity? Give real-world examples.
- [ ] 7. Explain O(n log n) complexity. Which algorithms have this complexity?
- [ ] 8. What is O(nÂ²) quadratic complexity? Give examples.
- [ ] 9. What is O(2^n) exponential complexity? When does it occur?
- [ ] 10. What is O(n!) factorial complexity? Provide examples.
- [ ] 11. How do you calculate the time complexity of nested loops?
- [ ] 12. What is amortized time complexity? Explain with dynamic array example.
- [ ] 13. How do you analyze recursive algorithms' time complexity?
- [ ] 14. What is the Master Theorem? How is it used?
- [ ] 15. Explain best case, average case, and worst case complexity.
- [ ] 16. What is the time complexity of accessing an array element?
- [ ] 17. Compare time complexity of linear search vs binary search.
- [ ] 18. What is auxiliary space complexity?
- [ ] 19. How do you optimize space complexity?
- [ ] 20. What is the space-time tradeoff? Give examples.
- [ ] 21. Calculate time complexity: for(i=0; i<n; i++) for(j=0; j<n; j++) sum++
- [ ] 22. Calculate time complexity: for(i=0; i<n; i++) for(j=i; j<n; j++) sum++
- [ ] 23. What is the complexity of T(n) = 2T(n/2) + O(n)?
- [ ] 24. Explain why hash table lookup is O(1) on average.
- [ ] 25. What is the time complexity of building a heap from an array?
- [ ] 26. Compare space complexity of iterative vs recursive solutions.
- [ ] 27. What is in-place algorithm? Give examples.
- [ ] 28. Explain stable vs unstable sorting algorithms.
- [ ] 29. What is the lower bound for comparison-based sorting?
- [ ] 30. How do you prove an algorithm's time complexity?

## Arrays

- [ ] 31. What is an array? How is it stored in memory?
- [ ] 32. What is the difference between static and dynamic arrays?
- [ ] 33. How do you reverse an array in-place?
- [ ] 34. Find the maximum and minimum element in an array.
- [ ] 35. How do you rotate an array by k positions?
- [ ] 36. Find the kth largest element in an array.
- [ ] 37. How do you remove duplicates from a sorted array?
- [ ] 38. Merge two sorted arrays into one sorted array.
- [ ] 39. Find the missing number in an array of 1 to n.
- [ ] 40. Find all pairs in an array that sum to a target value.
- [ ] 41. Implement the two-pointer technique. Give examples.
- [ ] 42. What is the sliding window technique? Solve maximum sum subarray of size k.
- [ ] 43. Find the longest subarray with sum equal to k.
- [ ] 44. Rearrange array in alternating positive and negative items.
- [ ] 45. Find the majority element (appears more than n/2 times).
- [ ] 46. Implement Moore's Voting Algorithm.
- [ ] 47. Find the subarray with maximum sum (Kadane's Algorithm).
- [ ] 48. Explain Kadane's Algorithm in detail.
- [ ] 49. Find the maximum product subarray.
- [ ] 50. How do you find duplicates in an array?
- [ ] 51. Find all triplets that sum to zero (3Sum problem).
- [ ] 52. Find the smallest positive missing number.
- [ ] 53. Rearrange array such that arr[i] = i.
- [ ] 54. Find the equilibrium index of an array.
- [ ] 55. Implement Dutch National Flag algorithm (sort 0s, 1s, 2s).
- [ ] 56. Find the next greater element for each element.
- [ ] 57. Stock buy and sell to maximize profit (single transaction).
- [ ] 58. Stock buy and sell to maximize profit (multiple transactions).
- [ ] 59. Trapping rainwater problem.
- [ ] 60. Container with most water problem.
- [ ] 61. Find the median of two sorted arrays.
- [ ] 62. Search in a rotated sorted array.
- [ ] 63. Find the rotation count in a rotated sorted array.
- [ ] 64. Find peak element in an array.
- [ ] 65. Implement sparse array multiplication.
- [ ] 66. Rearrange array in maximum minimum form.
- [ ] 67. Find the longest consecutive sequence.
- [ ] 68. Implement prefix sum array technique.
- [ ] 69. Range sum query using prefix sum.
- [ ] 70. Implement difference array technique.
- [ ] 71. Find subarrays with given sum.
- [ ] 72. Count inversions in an array.
- [ ] 73. Implement merge sort to count inversions.
- [ ] 74. Find the smallest subarray with sum greater than x.
- [ ] 75. Maximum circular subarray sum.
- [ ] 76. Rearrange array to maximize arr[i] - arr[j] where i > j.
- [ ] 77. Find the minimum distance between two numbers.
- [ ] 78. Segregate even and odd numbers.
- [ ] 79. Find common elements in three sorted arrays.
- [ ] 80. Implement array rotation using reversal algorithm.
- [ ] 81. Find the maximum difference arr[j] - arr[i] where j > i.
- [ ] 82. Implement sliding window maximum.
- [ ] 83. Find the longest increasing subarray.
- [ ] 84. Rearrange array such that even positioned are greater.
- [ ] 85. Find the minimum number of jumps to reach end.
- [ ] 86. Check if array can be sorted by swapping adjacent elements.
- [ ] 87. Find the maximum sum of i*arr[i].
- [ ] 88. Implement array as a circular buffer.
- [ ] 89. Find the smallest range covering elements from k lists.
- [ ] 90. Merge k sorted arrays.

## Strings

- [ ] 91. What is a string? How is it stored in memory?
- [ ] 92. Reverse a string in-place.
- [ ] 93. Check if a string is a palindrome.
- [ ] 94. Find the first non-repeating character in a string.
- [ ] 95. Check if two strings are anagrams.
- [ ] 96. Remove duplicates from a string.
- [ ] 97. Find all permutations of a string.
- [ ] 98. Implement string compression (e.g., "aabcccccaaa" â†’ "a2b1c5a3").
- [ ] 99. Check if one string is a rotation of another.
- [ ] 100. Implement strstr() function (find substring).
- [ ] 101. Longest common prefix among array of strings.
- [ ] 102. Longest palindromic substring.
- [ ] 103. Implement KMP (Knuth-Morris-Pratt) pattern matching.
- [ ] 104. Explain the failure function in KMP algorithm.
- [ ] 105. Implement Rabin-Karp algorithm for pattern matching.
- [ ] 106. What is rolling hash? How is it used in Rabin-Karp?
- [ ] 107. Implement Boyer-Moore algorithm.
- [ ] 108. Find all anagrams of a pattern in a text.
- [ ] 109. Longest substring without repeating characters.
- [ ] 110. Longest substring with at most k distinct characters.
- [ ] 111. Minimum window substring containing all characters.
- [ ] 112. Check if string has all unique characters.
- [ ] 113. Convert string to integer (atoi implementation).
- [ ] 114. Implement string to integer with error handling.
- [ ] 115. Reverse words in a string.
- [ ] 116. Remove spaces from a string.
- [ ] 117. Count and say sequence problem.
- [ ] 118. Valid palindrome (ignoring non-alphanumeric).
- [ ] 119. Longest repeating character replacement.
- [ ] 120. Group anagrams together.
- [ ] 121. Implement Trie (Prefix Tree).
- [ ] 122. Insert, search, and delete in Trie.
- [ ] 123. Find all words with a given prefix using Trie.
- [ ] 124. Implement autocomplete using Trie.
- [ ] 125. Longest common substring.
- [ ] 126. Edit distance (Levenshtein distance).
- [ ] 127. Wildcard pattern matching.
- [ ] 128. Regular expression matching.
- [ ] 129. Implement run-length encoding.
- [ ] 130. Implement run-length decoding.
- [ ] 131. Check if parentheses are balanced.
- [ ] 132. Generate all valid parentheses combinations.
- [ ] 133. Longest valid parentheses substring.
- [ ] 134. Remove invalid parentheses.
- [ ] 135. Implement string interleaving check.
- [ ] 136. Find the shortest palindrome by adding characters.
- [ ] 137. Count palindromic substrings.
- [ ] 138. Implement Z-algorithm for pattern matching.
- [ ] 139. Find lexicographically smallest string rotation.
- [ ] 140. Implement suffix array.
- [ ] 141. What is a suffix tree? How is it built?
- [ ] 142. Find longest repeated substring.
- [ ] 143. Implement Manacher's algorithm for longest palindrome.
- [ ] 144. Check if strings are k-distance apart.
- [ ] 145. Find all distinct palindromic substrings.
- [ ] 146. Implement string matching with wildcards.
- [ ] 147. Find the longest uncommon subsequence.
- [ ] 148. Decode ways (number to letter combinations).
- [ ] 149. Word break problem.
- [ ] 150. Word break II (return all solutions).

## Linked Lists

- [ ] 151. What is a linked list? Advantages over arrays?
- [ ] 152. Implement singly linked list with insert, delete, search.
- [ ] 153. Reverse a singly linked list (iterative).
- [ ] 154. Reverse a singly linked list (recursive).
- [ ] 155. Detect a cycle in a linked list (Floyd's algorithm).
- [ ] 156. Find the starting point of a cycle in a linked list.
- [ ] 157. Remove cycle from a linked list.
- [ ] 158. Find the middle element of a linked list.
- [ ] 159. Find the nth node from the end.
- [ ] 160. Delete a node given only pointer to that node.
- [ ] 161. Merge two sorted linked lists.
- [ ] 162. Merge k sorted linked lists.
- [ ] 163. Check if a linked list is a palindrome.
- [ ] 164. Remove duplicates from a sorted linked list.
- [ ] 165. Remove duplicates from an unsorted linked list.
- [ ] 166. Intersection point of two linked lists.
- [ ] 167. Add two numbers represented by linked lists.
- [ ] 168. Multiply two numbers represented by linked lists.
- [ ] 169. Clone a linked list with random pointers.
- [ ] 170. Flatten a multilevel linked list.
- [ ] 171. Reverse linked list in groups of k.
- [ ] 172. Rotate a linked list by k positions.
- [ ] 173. Segregate even and odd nodes.
- [ ] 174. Sort a linked list (merge sort).
- [ ] 175. Sort a linked list (quick sort).
- [ ] 176. Implement doubly linked list.
- [ ] 177. Implement circular linked list.
- [ ] 178. Delete nodes greater than x.
- [ ] 179. Rearrange linked list in zigzag fashion.
- [ ] 180. Partition list around value x.
- [ ] 181. Swap nodes in pairs.
- [ ] 182. Reverse alternate k nodes.
- [ ] 183. Delete alternate nodes.
- [ ] 184. Find triplet with given sum in three linked lists.
- [ ] 185. Implement LRU cache using linked list and hash map.
- [ ] 186. Implement LFU cache.
- [ ] 187. Design a stack using linked list.
- [ ] 188. Design a queue using linked list.
- [ ] 189. Implement skip list.
- [ ] 190. What is XOR linked list? Implement it.

## Stacks

- [ ] 191. What is a stack? Explain LIFO principle.
- [ ] 192. Implement stack using array.
- [ ] 193. Implement stack using linked list.
- [ ] 194. Implement two stacks in one array.
- [ ] 195. Implement k stacks in one array.
- [ ] 196. Implement stack with getMin() in O(1).
- [ ] 197. Implement stack that supports getMax() in O(1).
- [ ] 198. Check for balanced parentheses using stack.
- [ ] 199. Evaluate postfix expression.
- [ ] 200. Evaluate prefix expression.
- [ ] 201. Convert infix to postfix.
- [ ] 202. Convert infix to prefix.
- [ ] 203. Implement next greater element using stack.
- [ ] 204. Next smaller element for each element.
- [ ] 205. Stock span problem.
- [ ] 206. Largest rectangle in histogram.
- [ ] 207. Maximal rectangle in binary matrix.
- [ ] 208. Implement queue using stacks.
- [ ] 209. Implement stack using queues.
- [ ] 210. Sort a stack using recursion.
- [ ] 211. Sort a stack using another stack.
- [ ] 212. Reverse a stack using recursion.
- [ ] 213. Delete middle element of stack.
- [ ] 214. Check if stack permutation is valid.
- [ ] 215. Celebrity problem using stack.
- [ ] 216. Simplify Unix path using stack.
- [ ] 217. Decode string (nested brackets).
- [ ] 218. Remove k digits to get smallest number.
- [ ] 219. Trapping rainwater using stack.
- [ ] 220. Daily temperatures problem.

## Queues

- [ ] 221. What is a queue? Explain FIFO principle.
- [ ] 222. Implement queue using array.
- [ ] 223. Implement queue using linked list.
- [ ] 224. Implement circular queue.
- [ ] 225. Implement deque (double-ended queue).
- [ ] 226. Implement priority queue using array.
- [ ] 227. Implement priority queue using heap.
- [ ] 228. Implement queue using two stacks.
- [ ] 229. Implement stack using two queues.
- [ ] 230. Reverse a queue using recursion.
- [ ] 231. Reverse first k elements of queue.
- [ ] 232. Generate binary numbers from 1 to n using queue.
- [ ] 233. First non-repeating character in stream.
- [ ] 234. Sliding window maximum using deque.
- [ ] 235. Implement LRU cache using queue and hash map.
- [ ] 236. Rotten oranges problem (BFS).
- [ ] 237. First negative integer in every window of size k.
- [ ] 238. Interleave first and second half of queue.
- [ ] 239. Reverse a queue without using extra space.
- [ ] 240. Check if queue can be sorted using stack.

## Hash Tables

- [ ] 241. What is a hash table? How does it work?
- [ ] 242. What is a hash function? Properties of good hash function.
- [ ] 243. Explain collision resolution: chaining vs open addressing.
- [ ] 244. What is linear probing? Advantages and disadvantages.
- [ ] 245. What is quadratic probing?
- [ ] 246. What is double hashing?
- [ ] 247. What is load factor? How does it affect performance?
- [ ] 248. When should you resize a hash table?
- [ ] 249. Implement a hash map from scratch.
- [ ] 250. Find first repeating element.
- [ ] 251. Find first non-repeating element.
- [ ] 252. Count frequency of each element.
- [ ] 253. Find pairs with given sum using hash map.
- [ ] 254. Find four elements that sum to target (4Sum).
- [ ] 255. Longest consecutive sequence using hash set.
- [ ] 256. Group anagrams using hash map.
- [ ] 257. Subarray with sum 0.
- [ ] 258. Longest subarray with sum k.
- [ ] 259. Count subarrays with given sum.
- [ ] 260. Find itinerary from tickets (hash map).
- [ ] 261. Implement LRU cache with hash map and doubly linked list.
- [ ] 262. Design hash set.
- [ ] 263. Design hash map.
- [ ] 264. Find all pairs with given difference.
- [ ] 265. Check if array can be divided into pairs with sum divisible by k.
- [ ] 266. Longest substring with k unique characters.
- [ ] 267. Count distinct elements in every window.
- [ ] 268. Find symmetric pairs in array.
- [ ] 269. Check if two arrays are disjoint.
- [ ] 270. Union and intersection of arrays.

## Trees

- [ ] 271. What is a tree? Define node, root, leaf, height, depth.
- [ ] 272. What is a binary tree?
- [ ] 273. Types of binary trees: full, complete, perfect, balanced.
- [ ] 274. Implement binary tree node structure.
- [ ] 275. Inorder traversal (recursive).
- [ ] 276. Preorder traversal (recursive).
- [ ] 277. Postorder traversal (recursive).
- [ ] 278. Inorder traversal (iterative using stack).
- [ ] 279. Preorder traversal (iterative).
- [ ] 280. Postorder traversal (iterative).
- [ ] 281. Level order traversal (BFS).
- [ ] 282. Reverse level order traversal.
- [ ] 283. Zigzag level order traversal.
- [ ] 284. Height of binary tree.
- [ ] 285. Diameter of binary tree.
- [ ] 286. Check if two trees are identical.
- [ ] 287. Check if tree is symmetric (mirror).
- [ ] 288. Invert/mirror a binary tree.
- [ ] 289. Find maximum element in binary tree.
- [ ] 290. Count nodes in binary tree.
- [ ] 291. Count leaf nodes.
- [ ] 292. Sum of all nodes.
- [ ] 293. Check if tree is height balanced.
- [ ] 294. Convert binary tree to its mirror.
- [ ] 295. Lowest common ancestor (LCA) in binary tree.
- [ ] 296. Print all paths from root to leaf.
- [ ] 297. Check if path with given sum exists.
- [ ] 298. Find all paths with given sum.
- [ ] 299. Maximum path sum in binary tree.
- [ ] 300. Construct tree from inorder and preorder.
- [ ] 301. Construct tree from inorder and postorder.
- [ ] 302. Serialize and deserialize binary tree.
- [ ] 303. Vertical order traversal.
- [ ] 304. Top view of binary tree.
- [ ] 305. Bottom view of binary tree.
- [ ] 306. Left view of binary tree.
- [ ] 307. Right view of binary tree.
- [ ] 308. Boundary traversal of binary tree.
- [ ] 309. Diagonal traversal.
- [ ] 310. Connect nodes at same level.
- [ ] 311. Convert binary tree to doubly linked list.
- [ ] 312. Find distance between two nodes.
- [ ] 313. Kth ancestor of a node.
- [ ] 314. Print all nodes at distance k from target.
- [ ] 315. Check if binary tree is subtree of another.
- [ ] 316. Find duplicate subtrees.
- [ ] 317. Binary tree to binary search tree conversion.
- [ ] 318. What is a Binary Search Tree (BST)?
- [ ] 319. Insert node in BST.
- [ ] 320. Delete node from BST.
- [ ] 321. Search in BST.
- [ ] 322. Find minimum in BST.
- [ ] 323. Find maximum in BST.
- [ ] 324. Inorder successor in BST.
- [ ] 325. Inorder predecessor in BST.
- [ ] 326. Check if tree is BST.
- [ ] 327. Lowest common ancestor in BST.
- [ ] 328. Convert sorted array to BST.
- [ ] 329. Convert sorted linked list to BST.
- [ ] 330. Kth smallest element in BST.
- [ ] 331. Kth largest element in BST.
- [ ] 332. Find pair with given sum in BST.
- [ ] 333. BST to greater sum tree.
- [ ] 334. Merge two BSTs.
- [ ] 335. Find inorder successor without parent pointer.
- [ ] 336. Recover BST (two nodes swapped).
- [ ] 337. Range sum query in BST.
- [ ] 338. Count BST nodes in a range.
- [ ] 339. What is an AVL tree?
- [ ] 340. Implement AVL tree rotations (LL, RR, LR, RL).
- [ ] 341. Insert in AVL tree with balancing.
- [ ] 342. Delete from AVL tree with balancing.
- [ ] 343. What is a Red-Black tree?
- [ ] 344. Properties of Red-Black tree.
- [ ] 345. What is a B-tree? Where is it used?
- [ ] 346. What is a B+ tree?
- [ ] 347. Implement segment tree.
- [ ] 348. Range minimum query using segment tree.
- [ ] 349. Range sum query using segment tree.
- [ ] 350. Lazy propagation in segment tree.
- [ ] 351. What is a Fenwick tree (Binary Indexed Tree)?
- [ ] 352. Implement Fenwick tree for prefix sums.
- [ ] 353. Range update using Fenwick tree.
- [ ] 354. What is a Trie? Implement it.
- [ ] 355. Insert, search, delete in Trie.
- [ ] 356. Count words with given prefix.
- [ ] 357. Longest common prefix using Trie.
- [ ] 358. Implement autocomplete with Trie.
- [ ] 359. Word search in 2D grid using Trie.
- [ ] 360. Maximum XOR of two numbers using Trie.

## Heaps

- [ ] 361. What is a heap? Min-heap vs max-heap.
- [ ] 362. What is the heap property?
- [ ] 363. Implement min-heap.
- [ ] 364. Implement max-heap.
- [ ] 365. Insert element in heap.
- [ ] 366. Delete element from heap.
- [ ] 367. Extract minimum from min-heap.
- [ ] 368. Extract maximum from max-heap.
- [ ] 369. Heapify operation.
- [ ] 370. Build heap from array.
- [ ] 371. Heap sort algorithm.
- [ ] 372. Time complexity of heap operations.
- [ ] 373. Find kth largest element using heap.
- [ ] 374. Find kth smallest element using heap.
- [ ] 375. Merge k sorted arrays using heap.
- [ ] 376. Merge k sorted linked lists using heap.
- [ ] 377. Find median in a stream.
- [ ] 378. Top k frequent elements.
- [ ] 379. K closest points to origin.
- [ ] 380. Connect ropes with minimum cost.
- [ ] 381. Huffman coding using heap.
- [ ] 382. Sliding window median.
- [ ] 383. Find smallest range covering k lists.
- [ ] 384. Reorganize string (no adjacent duplicates).
- [ ] 385. Task scheduler problem.
- [ ] 386. Implement priority queue using heap.
- [ ] 387. K closest elements to target.
- [ ] 388. Kth largest element in stream.
- [ ] 389. Sort nearly sorted array.
- [ ] 390. Replace each element with least greater on right.

## Graphs

- [ ] 391. What is a graph? Vertices and edges.
- [ ] 392. Directed vs undirected graph.
- [ ] 393. Weighted vs unweighted graph.
- [ ] 394. Cyclic vs acyclic graph.
- [ ] 395. Connected vs disconnected graph.
- [ ] 396. What is a DAG (Directed Acyclic Graph)?
- [ ] 397. Graph representation: adjacency matrix.
- [ ] 398. Graph representation: adjacency list.
- [ ] 399. Which representation is better and when?
- [ ] 400. Implement graph using adjacency list.
- [ ] 401. Breadth-First Search (BFS) algorithm.
- [ ] 402. Implement BFS iteratively.
- [ ] 403. Depth-First Search (DFS) algorithm.
- [ ] 404. Implement DFS recursively.
- [ ] 405. Implement DFS iteratively.
- [ ] 406. Detect cycle in undirected graph (DFS).
- [ ] 407. Detect cycle in undirected graph (BFS/Union-Find).
- [ ] 408. Detect cycle in directed graph.
- [ ] 409. Topological sort using DFS.
- [ ] 410. Topological sort using BFS (Kahn's algorithm).
- [ ] 411. Check if graph is bipartite (BFS).
- [ ] 412. Check if graph is bipartite (DFS).
- [ ] 413. Find all connected components.
- [ ] 414. Count connected components.
- [ ] 415. Find shortest path in unweighted graph (BFS).
- [ ] 416. Dijkstra's shortest path algorithm.
- [ ] 417. Implement Dijkstra using priority queue.
- [ ] 418. Bellman-Ford algorithm.
- [ ] 419. When to use Bellman-Ford over Dijkstra?
- [ ] 420. Floyd-Warshall algorithm (all pairs shortest path).
- [ ] 421. Detect negative cycle using Bellman-Ford.
- [ ] 422. Minimum spanning tree (MST) - what is it?
- [ ] 423. Prim's algorithm for MST.
- [ ] 424. Kruskal's algorithm for MST.
- [ ] 425. Union-Find (Disjoint Set Union) data structure.
- [ ] 426. Path compression in Union-Find.
- [ ] 427. Union by rank in Union-Find.
- [ ] 428. Detect cycle using Union-Find.
- [ ] 429. Number of islands problem.
- [ ] 430. Clone a graph.
- [ ] 431. Word ladder problem.
- [ ] 432. Course schedule (detect cycle in directed graph).
- [ ] 433. Course schedule II (topological sort).
- [ ] 434. Alien dictionary (topological sort).
- [ ] 435. Find bridges in graph (Tarjan's algorithm).
- [ ] 436. Find articulation points.
- [ ] 437. Strongly connected components (Kosaraju's algorithm).
- [ ] 438. Strongly connected components (Tarjan's algorithm).
- [ ] 439. Eulerian path and circuit.
- [ ] 440. Hamiltonian path and cycle.
- [ ] 441. Travelling salesman problem (TSP).
- [ ] 442. Graph coloring problem.
- [ ] 443. Minimum height trees.
- [ ] 444. Network delay time.
- [ ] 445. Cheapest flights within k stops.
- [ ] 446. Reconstruct itinerary.
- [ ] 447. Critical connections in network.
- [ ] 448. Accounts merge (Union-Find).
- [ ] 449. Redundant connection.
- [ ] 450. Evaluate division (graph with weights).

## Sorting Algorithms

- [ ] 451. What is sorting? Stable vs unstable sorting.
- [ ] 452. Bubble sort algorithm and implementation.
- [ ] 453. Time and space complexity of bubble sort.
- [ ] 454. Optimized bubble sort.
- [ ] 455. Selection sort algorithm and implementation.
- [ ] 456. Time and space complexity of selection sort.
- [ ] 457. Insertion sort algorithm and implementation.
- [ ] 458. Time and space complexity of insertion sort.
- [ ] 459. When is insertion sort efficient?
- [ ] 460. Merge sort algorithm and implementation.
- [ ] 461. Time and space complexity of merge sort.
- [ ] 462. Is merge sort stable?
- [ ] 463. Quick sort algorithm and implementation.
- [ ] 464. Partition function in quick sort.
- [ ] 465. Time and space complexity of quick sort.
- [ ] 466. Best and worst case of quick sort.
- [ ] 467. How to choose pivot in quick sort?
- [ ] 468. Randomized quick sort.
- [ ] 469. Is quick sort stable?
- [ ] 470. Heap sort algorithm.
- [ ] 471. Time and space complexity of heap sort.
- [ ] 472. Counting sort algorithm.
- [ ] 473. When to use counting sort?
- [ ] 474. Time and space complexity of counting sort.
- [ ] 475. Radix sort algorithm.
- [ ] 476. Time complexity of radix sort.
- [ ] 477. Bucket sort algorithm.
- [ ] 478. Shell sort algorithm.
- [ ] 479. Tim sort (used in Python and Java).
- [ ] 480. Compare all sorting algorithms.
- [ ] 481. Sort array of 0s, 1s, and 2s (Dutch flag).
- [ ] 482. Sort array by frequency.
- [ ] 483. Sort array by parity (even first).
- [ ] 484. Wiggle sort.
- [ ] 485. Pancake sorting.
- [ ] 486. Sort colors problem.
- [ ] 487. Merge sort for linked list.
- [ ] 488. Quick sort for linked list.
- [ ] 489. External sorting.
- [ ] 490. Topological sorting.

## Searching Algorithms

- [ ] 491. Linear search algorithm.
- [ ] 492. Time complexity of linear search.
- [ ] 493. Binary search algorithm (iterative).
- [ ] 494. Binary search algorithm (recursive).
- [ ] 495. Time and space complexity of binary search.
- [ ] 496. Find first occurrence using binary search.
- [ ] 497. Find last occurrence using binary search.
- [ ] 498. Count occurrences using binary search.
- [ ] 499. Search in rotated sorted array.
- [ ] 500. Find minimum in rotated sorted array.
- [ ] 501. Find peak element.
- [ ] 502. Search in 2D matrix (sorted rows and columns).
- [ ] 503. Search in row-wise and column-wise sorted matrix.
- [ ] 504. Find square root using binary search.
- [ ] 505. Find cube root using binary search.
- [ ] 506. Allocate minimum pages (binary search).
- [ ] 507. Aggressive cows problem.
- [ ] 508. Painter's partition problem.
- [ ] 509. Median of two sorted arrays.
- [ ] 510. Kth element in two sorted arrays.
- [ ] 511. Exponential search.
- [ ] 512. Interpolation search.
- [ ] 513. Jump search.
- [ ] 514. Fibonacci search.
- [ ] 515. Ternary search.
- [ ] 516. Find fixed point (value equals index).
- [ ] 517. Find majority element (Boyer-Moore).
- [ ] 518. Find missing number in arithmetic progression.
- [ ] 519. Find the odd occurring element.
- [ ] 520. Bitonic array maximum.

## Recursion

- [ ] 521. What is recursion? Base case and recursive case.
- [ ] 522. How does recursion work internally (call stack)?
- [ ] 523. Tail recursion vs head recursion.
- [ ] 524. What is tail call optimization?
- [ ] 525. Calculate factorial using recursion.
- [ ] 526. Calculate Fibonacci using recursion.
- [ ] 527. Why is recursive Fibonacci inefficient?
- [ ] 528. Print numbers from 1 to n using recursion.
- [ ] 529. Print numbers from n to 1 using recursion.
- [ ] 530. Sum of n natural numbers using recursion.
- [ ] 531. Sum of digits using recursion.
- [ ] 532. Reverse a string using recursion.
- [ ] 533. Check palindrome using recursion.
- [ ] 534. Power function (x^n) using recursion.
- [ ] 535. Optimized power function (O(log n)).
- [ ] 536. Tower of Hanoi problem.
- [ ] 537. Print all subsets of a set.
- [ ] 538. Print all permutations of string.
- [ ] 539. Print all combinations of string.
- [ ] 540. Generate all binary strings of length n.
- [ ] 541. Generate all balanced parentheses.
- [ ] 542. Print all paths in matrix from top-left to bottom-right.
- [ ] 543. Flood fill algorithm.
- [ ] 544. Josephus problem.
- [ ] 545. Count ways to reach nth stair.
- [ ] 546. Print all subsequences of string.
- [ ] 547. Length of longest increasing subsequence (recursion).
- [ ] 548. Recursion vs iteration: when to use which?
- [ ] 549. Convert recursive solution to iterative.
- [ ] 550. Memoization in recursion.

## Dynamic Programming

- [ ] 551. What is dynamic programming (DP)?
- [ ] 552. Overlapping subproblems property.
- [ ] 553. Optimal substructure property.
- [ ] 554. Top-down vs bottom-up approach.
- [ ] 555. Memoization vs tabulation.
- [ ] 556. Fibonacci using DP (memoization).
- [ ] 557. Fibonacci using DP (tabulation).
- [ ] 558. Climbing stairs problem.
- [ ] 559. Minimum cost climbing stairs.
- [ ] 560. House robber problem.
- [ ] 561. House robber II (circular).
- [ ] 562. Coin change problem (minimum coins).
- [ ] 563. Coin change II (number of ways).
- [ ] 564. 0/1 Knapsack problem.
- [ ] 565. Unbounded knapsack problem.
- [ ] 566. Subset sum problem.
- [ ] 567. Equal sum partition.
- [ ] 568. Count of subset sum.
- [ ] 569. Minimum subset sum difference.
- [ ] 570. Target sum (assign + or -).
- [ ] 571. Longest common subsequence (LCS).
- [ ] 572. Print LCS.
- [ ] 573. Longest common substring.
- [ ] 574. Shortest common supersequence.
- [ ] 575. Minimum insertions/deletions to convert string.
- [ ] 576. Longest palindromic subsequence.
- [ ] 577. Minimum deletions to make palindrome.
- [ ] 578. Longest increasing subsequence (LIS).
- [ ] 579. Print LIS.
- [ ] 580. Number of LIS.
- [ ] 581. Russian doll envelopes.
- [ ] 582. Maximum sum increasing subsequence.
- [ ] 583. Longest bitonic subsequence.
- [ ] 584. Edit distance (Levenshtein).
- [ ] 585. Wildcard pattern matching DP.
- [ ] 586. Regular expression matching DP.
- [ ] 587. Distinct subsequences.
- [ ] 588. Interleaving strings.
- [ ] 589. Word break DP.
- [ ] 590. Palindrome partitioning (minimum cuts).
- [ ] 591. Matrix chain multiplication.
- [ ] 592. Egg dropping problem.
- [ ] 593. Optimal binary search tree.
- [ ] 594. Boolean parenthesization.
- [ ] 595. Burst balloons.
- [ ] 596. Minimum cost to merge stones.
- [ ] 597. Partition array for maximum sum.
- [ ] 598. Maximal square in matrix.
- [ ] 599. Maximal rectangle in matrix.
- [ ] 600. Unique paths in grid.
- [ ] 601. Unique paths with obstacles.
- [ ] 602. Minimum path sum in grid.
- [ ] 603. Maximum path sum in grid.
- [ ] 604. Triangle minimum path sum.
- [ ] 605. Dungeon game.
- [ ] 606. Cherry pickup.
- [ ] 607. Best time to buy/sell stock (all variants).
- [ ] 608. Stock with cooldown.
- [ ] 609. Stock with transaction fee.
- [ ] 610. Decode ways DP.
- [ ] 611. Unique BSTs (Catalan number).
- [ ] 612. Catalan number applications.
- [ ] 613. Count ways to tile floor.
- [ ] 614. Count ways to build.
- [ ] 615. Partition problem variants.
- [ ] 616. Rod cutting problem.
- [ ] 617. Maximum ribbon cut.
- [ ] 618. Minimum jumps to reach end.
- [ ] 619. Jump game variants.
- [ ] 620. Longest arithmetic subsequence.
- [ ] 621. Longest geometric subsequence.
- [ ] 622. Count palindromic subsequences.
- [ ] 623. DP on trees.
- [ ] 624. DP with bitmasks.
- [ ] 625. Travelling salesman DP.
- [ ] 626. Digit DP.
- [ ] 627. DP optimization techniques.
- [ ] 628. Space optimization in DP.
- [ ] 629. State compression.
- [ ] 630. Divide and conquer DP.

## Greedy Algorithms

- [ ] 631. What is a greedy algorithm?
- [ ] 632. Greedy choice property.
- [ ] 633. When does greedy approach work?
- [ ] 634. Greedy vs dynamic programming.
- [ ] 635. Activity selection problem.
- [ ] 636. Fractional knapsack problem.
- [ ] 637. Job sequencing problem.
- [ ] 638. Huffman coding.
- [ ] 639. Minimum platforms required.
- [ ] 640. Minimum number of coins.
- [ ] 641. Minimum number of arrows to burst balloons.
- [ ] 642. Non-overlapping intervals.
- [ ] 643. Merge intervals.
- [ ] 644. Insert interval.
- [ ] 645. Meeting rooms problem.
- [ ] 646. Meeting rooms II (minimum rooms).
- [ ] 647. Jump game (can reach end).
- [ ] 648. Jump game II (minimum jumps).
- [ ] 649. Gas station problem.
- [ ] 650. Candy distribution.
- [ ] 651. Assign cookies.
- [ ] 652. Lemonade change.
- [ ] 653. Queue reconstruction by height.
- [ ] 654. Partition labels.
- [ ] 655. Reorganize string (greedy).
- [ ] 656. Task scheduler (greedy).
- [ ] 657. Remove k digits (greedy).
- [ ] 658. Create maximum number.
- [ ] 659. Monotone increasing digits.
- [ ] 660. Minimum deletions to make valid parentheses.

## Backtracking

- [ ] 661. What is backtracking?
- [ ] 662. Backtracking vs recursion vs brute force.
- [ ] 663. N-Queens problem.
- [ ] 664. Print all solutions to N-Queens.
- [ ] 665. Sudoku solver.
- [ ] 666. Rat in a maze.
- [ ] 667. Knight's tour problem.
- [ ] 668. Word search in 2D grid.
- [ ] 669. Generate all permutations (backtracking).
- [ ] 670. Generate all combinations.
- [ ] 671. Combination sum (elements can repeat).
- [ ] 672. Combination sum II (each element once).
- [ ] 673. Combination sum III.
- [ ] 674. Subsets (power set).
- [ ] 675. Subsets II (with duplicates).
- [ ] 676. Palindrome partitioning (all partitions).
- [ ] 677. Letter combinations of phone number.
- [ ] 678. Generate parentheses (backtracking).
- [ ] 679. Restore IP addresses.
- [ ] 680. Word break II (backtracking).
- [ ] 681. Expression add operators.
- [ ] 682. Remove invalid parentheses (backtracking).
- [ ] 683. Matchsticks to square.
- [ ] 684. Partition to k equal sum subsets.
- [ ] 685. Beautiful arrangement.
- [ ] 686. Permutation sequence.
- [ ] 687. Gray code.
- [ ] 688. Generalized abbreviation.
- [ ] 689. Android unlock patterns.
- [ ] 690. Optimal account balancing.

## Bit Manipulation

- [ ] 691. What is bit manipulation?
- [ ] 692. Bitwise AND, OR, XOR, NOT operators.
- [ ] 693. Left shift (<<) and right shift (>>) operators.
- [ ] 694. Check if number is even or odd using bits.
- [ ] 695. Check if ith bit is set.
- [ ] 696. Set the ith bit.
- [ ] 697. Clear the ith bit.
- [ ] 698. Toggle the ith bit.
- [ ] 699. Count number of set bits (Hamming weight).
- [ ] 700. Brian Kernighan's algorithm.
- [ ] 701. Check if number is power of 2.
- [ ] 702. Find the only non-repeating element (XOR).
- [ ] 703. Find two non-repeating elements.
- [ ] 704. Find the missing number using XOR.
- [ ] 705. Swap two numbers without temp variable.
- [ ] 706. Reverse bits of a number.
- [ ] 707. Count bits to flip to convert A to B.
- [ ] 708. Find position of rightmost set bit.
- [ ] 709. Find position of only set bit.
- [ ] 710. Check if number has alternate bits.
- [ ] 711. Add two numbers using bitwise operators.
- [ ] 712. Subtract using bitwise operators.
- [ ] 713. Multiply using bitwise operators.
- [ ] 714. Divide using bitwise operators.
- [ ] 715. Find XOR from 1 to n.
- [ ] 716. XOR of all subarrays.
- [ ] 717. Maximum XOR of two numbers in array.
- [ ] 718. Maximum XOR with element from array.
- [ ] 719. Count total set bits from 1 to n.
- [ ] 720. Generate all subsets using bits.
- [ ] 721. Find the element appearing once (others thrice).
- [ ] 722. Single number III.
- [ ] 723. Power set using bit manipulation.
- [ ] 724. Gray code generation.
- [ ] 725. Hamming distance.
- [ ] 726. Total Hamming distance.
- [ ] 727. Bitwise AND of range.
- [ ] 728. Longest consecutive 1s in binary.
- [ ] 729. Count numbers with unique digits.
- [ ] 730. UTF-8 validation.

## Mathematical Algorithms

- [ ] 731. Check if number is prime.
- [ ] 732. Sieve of Eratosthenes.
- [ ] 733. Segmented sieve.
- [ ] 734. Prime factorization.
- [ ] 735. Count prime numbers less than n.
- [ ] 736. GCD (Greatest Common Divisor) - Euclidean algorithm.
- [ ] 737. LCM (Least Common Multiple).
- [ ] 738. Extended Euclidean algorithm.
- [ ] 739. Modular arithmetic basics.
- [ ] 740. Modular exponentiation.
- [ ] 741. Modular multiplicative inverse.
- [ ] 742. Fast exponentiation (power in O(log n)).
- [ ] 743. Factorial of large number.
- [ ] 744. Trailing zeros in factorial.
- [ ] 745. nCr (combinations) calculation.
- [ ] 746. nPr (permutations) calculation.
- [ ] 747. Pascal's triangle.
- [ ] 748. Catalan numbers.
- [ ] 749. Fibonacci in O(log n) using matrix.
- [ ] 750. Check if number is perfect square.
- [ ] 751. Integer square root.
- [ ] 752. Check if number is palindrome.
- [ ] 753. Reverse an integer.
- [ ] 754. Count digits in a number.
- [ ] 755. Sum of digits.
- [ ] 756. Product of digits.
- [ ] 757. Armstrong number check.
- [ ] 758. Perfect number check.
- [ ] 759. Happy number.
- [ ] 760. Ugly number.
- [ ] 761. Ugly number II (nth ugly number).
- [ ] 762. Super ugly number.
- [ ] 763. Excel sheet column number.
- [ ] 764. Excel sheet column title.
- [ ] 765. Roman to integer.
- [ ] 766. Integer to roman.
- [ ] 767. Add binary strings.
- [ ] 768. Multiply strings.
- [ ] 769. Pow(x, n).
- [ ] 770. Sqrt(x).
- [ ] 771. Valid perfect square.
- [ ] 772. Arranging coins.
- [ ] 773. Reach a number.
- [ ] 774. Consecutive numbers sum.
- [ ] 775. Rectangle overlap.
- [ ] 776. Rectangle area.
- [ ] 777. Valid triangle number.
- [ ] 778. Largest triangle area.
- [ ] 779. Water and jug problem.
- [ ] 780. Bulb switcher.

## Advanced Topics

### Advanced Data Structures (20)

- [ ] 781. What is a Disjoint Set Union (Union-Find)?
- [ ] 782. Implement Union-Find with path compression.
- [ ] 783. Implement Union-Find with union by rank.
- [ ] 784. Applications of Union-Find.
- [ ] 785. What is a Segment Tree?
- [ ] 786. Build segment tree.
- [ ] 787. Range query in segment tree.
- [ ] 788. Update query in segment tree.
- [ ] 789. Lazy propagation in segment tree.
- [ ] 790. What is a Fenwick Tree (BIT)?
- [ ] 791. Implement Fenwick tree.
- [ ] 792. Range sum using Fenwick tree.
- [ ] 793. Point update in Fenwick tree.
- [ ] 794. 2D Fenwick tree.
- [ ] 795. Sparse table for range queries.
- [ ] 796. Square root decomposition.
- [ ] 797. Mo's algorithm.
- [ ] 798. Persistent data structures.
- [ ] 799. Persistent segment tree.
- [ ] 800. Treap (Tree + Heap).

### String Algorithms Advanced (10)

- [ ] 801. Suffix array construction.
- [ ] 802. LCP (Longest Common Prefix) array.
- [ ] 803. Suffix tree construction.
- [ ] 804. Applications of suffix tree.
- [ ] 805. Aho-Corasick algorithm.
- [ ] 806. Z-algorithm implementation.
- [ ] 807. Manacher's algorithm.
- [ ] 808. Palindromic tree.
- [ ] 809. Burrows-Wheeler transform.
- [ ] 810. String hashing techniques.

### Graph Algorithms Advanced (20)

- [ ] 811. Articulation points and bridges.
- [ ] 812. Tarjan's algorithm for SCC.
- [ ] 813. Kosaraju's algorithm for SCC.
- [ ] 814. Eulerian path and circuit algorithms.
- [ ] 815. Hierholzer's algorithm.
- [ ] 816. Chinese postman problem.
- [ ] 817. Maximum flow (Ford-Fulkerson).
- [ ] 818. Edmonds-Karp algorithm.
- [ ] 819. Dinic's algorithm.
- [ ] 820. Push-relabel algorithm.
- [ ] 821. Minimum cut in graph.
- [ ] 822. Bipartite matching.
- [ ] 823. Hungarian algorithm.
- [ ] 824. Hopcroft-Karp algorithm.
- [ ] 825. Stable marriage problem.
- [ ] 826. A* search algorithm.
- [ ] 827. Bidirectional search.
- [ ] 828. Johnson's algorithm.
- [ ] 829. Centroid decomposition.
- [ ] 830. Heavy-light decomposition.

### Advanced DP (10)

- [ ] 831. DP on trees - introduction.
- [ ] 832. Rerooting technique.
- [ ] 833. DP with bitmasking.
- [ ] 834. Subset DP.
- [ ] 835. Digit DP problems.
- [ ] 836. DP optimization - Convex Hull Trick.
- [ ] 837. DP optimization - Divide and Conquer.
- [ ] 838. Knuth's optimization.
- [ ] 839. Slope trick in DP.
- [ ] 840. SOS (Sum over Subsets) DP.

### Computational Geometry (10)

- [ ] 841. Point and line representation.
- [ ] 842. Distance between two points.
- [ ] 843. Check if point lies on line segment.
- [ ] 844. Orientation of ordered triplet.
- [ ] 845. Check if two line segments intersect.
- [ ] 846. Convex hull - Graham scan.
- [ ] 847. Convex hull - Jarvis march.
- [ ] 848. Closest pair of points.
- [ ] 849. Line sweep algorithm.
- [ ] 850. Point in polygon test.

### Number Theory Advanced (10)

- [ ] 851. Chinese remainder theorem.
- [ ] 852. Euler's totient function.
- [ ] 853. Fermat's little theorem.
- [ ] 854. Wilson's theorem.
- [ ] 855. Miller-Rabin primality test.
- [ ] 856. Pollard's rho algorithm.
- [ ] 857. Discrete logarithm.
- [ ] 858. Baby-step giant-step.
- [ ] 859. Linear Diophantine equations.
- [ ] 860. Gaussian elimination.

### Game Theory (10)

- [ ] 861. Nim game.
- [ ] 862. Grundy numbers.
- [ ] 863. Sprague-Grundy theorem.
- [ ] 864. Minimax algorithm.
- [ ] 865. Alpha-beta pruning.
- [ ] 866. Game tree evaluation.
- [ ] 867. Stone game variants.
- [ ] 868. Flip game.
- [ ] 869. Predict the winner.
- [ ] 870. Can I win.

### Divide and Conquer (10)

- [ ] 871. Merge sort implementation.
- [ ] 872. Quick sort implementation.
- [ ] 873. Binary search applications.
- [ ] 874. Closest pair of points (D&C).
- [ ] 875. Strassen's matrix multiplication.
- [ ] 876. Karatsuba multiplication.
- [ ] 877. Maximum subarray (D&C).
- [ ] 878. Count inversions.
- [ ] 879. Median of medians algorithm.
- [ ] 880. Fast Fourier Transform (FFT).

### Randomized Algorithms (10)

- [ ] 881. Randomized quick sort.
- [ ] 882. Randomized selection.
- [ ] 883. Skip list.
- [ ] 884. Bloom filter.
- [ ] 885. Count-min sketch.
- [ ] 886. Reservoir sampling.
- [ ] 887. Fisher-Yates shuffle.
- [ ] 888. Monte Carlo algorithms.
- [ ] 889. Las Vegas algorithms.
- [ ] 890. Randomized primality testing.

### Approximation Algorithms (10)

- [ ] 891. Vertex cover approximation.
- [ ] 892. TSP approximation.
- [ ] 893. Set cover approximation.
- [ ] 894. Bin packing approximation.
- [ ] 895. Load balancing.
- [ ] 896. Knapsack approximation.
- [ ] 897. Metric TSP.
- [ ] 898. Steiner tree approximation.
- [ ] 899. Max-cut approximation.
- [ ] 900. Scheduling approximation.

### Pattern Matching (10)

- [ ] 901. Naive pattern matching.
- [ ] 902. KMP algorithm detailed.
- [ ] 903. Boyer-Moore algorithm.
- [ ] 904. Rabin-Karp detailed.
- [ ] 905. Finite automata pattern matching.
- [ ] 906. Two-dimensional pattern matching.
- [ ] 907. Wildcard matching.
- [ ] 908. Regular expression implementation.
- [ ] 909. Longest common substring (advanced).
- [ ] 910. All occurrences of pattern.

### Matrix Algorithms (10)

- [ ] 911. Matrix multiplication.
- [ ] 912. Matrix exponentiation.
- [ ] 913. Rotate matrix 90 degrees.
- [ ] 914. Spiral matrix traversal.
- [ ] 915. Set matrix zeros.
- [ ] 916. Search in 2D matrix.
- [ ] 917. Diagonal traversal.
- [ ] 918. Toeplitz matrix.
- [ ] 919. Valid Sudoku.
- [ ] 920. Sudoku solver (backtracking).

### Design Problems (20)

- [ ] 921. LRU Cache implementation.
- [ ] 922. LFU Cache implementation.
- [ ] 923. Design Twitter.
- [ ] 924. Design search autocomplete.
- [ ] 925. Design file system.
- [ ] 926. Design in-memory database.
- [ ] 927. Implement Trie with wildcard search.
- [ ] 928. Design hit counter.
- [ ] 929. Design rate limiter.
- [ ] 930. Design URL shortener.
- [ ] 931. Design parking lot.
- [ ] 932. Design elevator system.
- [ ] 933. Design snake game.
- [ ] 934. Design tic-tac-toe.
- [ ] 935. Design chess validator.
- [ ] 936. Implement calculator.
- [ ] 937. Basic calculator II.
- [ ] 938. Expression evaluation.
- [ ] 939. Serialize and deserialize BST.
- [ ] 940. Serialize and deserialize N-ary tree.

### System Design Algorithms (10)

- [ ] 941. Consistent hashing.
- [ ] 942. Rendezvous hashing.
- [ ] 943. Distributed hash table.
- [ ] 944. Merkle tree.
- [ ] 945. Bloom filter implementation.
- [ ] 946. HyperLogLog.
- [ ] 947. Count-min sketch implementation.
- [ ] 948. Geohashing.
- [ ] 949. Quadtree.
- [ ] 950. R-tree.

### Interview Favorites (20)

- [ ] 951. Implement atoi (string to integer).
- [ ] 952. Implement itoa (integer to string).
- [ ] 953. Reverse linked list in k groups.
- [ ] 954. Merge k sorted lists.
- [ ] 955. Trapping rainwater.
- [ ] 956. Largest rectangle in histogram.
- [ ] 957. Median of data stream.
- [ ] 958. Sliding window maximum.
- [ ] 959. Longest substring without repeating characters.
- [ ] 960. Minimum window substring.
- [ ] 961. Word ladder.
- [ ] 962. Word ladder II.
- [ ] 963. Alien dictionary.
- [ ] 964. Course schedule.
- [ ] 965. Number of islands.
- [ ] 966. Clone graph.
- [ ] 967. Serialize deserialize binary tree.
- [ ] 968. Binary tree maximum path sum.
- [ ] 969. Lowest common ancestor.
- [ ] 970. Kth smallest in BST.

### Final Advanced Challenges (30)

- [ ] 971. Regular expression matching (DP).
- [ ] 972. Wildcard matching (DP).
- [ ] 973. Edit distance variations.
- [ ] 974. Longest palindromic substring (all methods).
- [ ] 975. Palindrome partitioning II.
- [ ] 976. Word break II (all solutions).
- [ ] 977. N-Queens II (count solutions).
- [ ] 978. Sudoku solver optimization.
- [ ] 979. Expression add operators (all combinations).
- [ ] 980. Remove invalid parentheses (minimum removals).
- [ ] 981. Burst balloons (optimal).
- [ ] 982. Strange printer.
- [ ] 983. Frog jump.
- [ ] 984. Russian doll envelopes.
- [ ] 985. Max sum of rectangle no larger than k.
- [ ] 986. Split array largest sum.
- [ ] 987. Create maximum number.
- [ ] 988. Count of range sum.
- [ ] 989. Reverse pairs.
- [ ] 990. Count of smaller numbers after self.
- [ ] 991. Queue reconstruction by height.
- [ ] 992. Reconstruct itinerary.
- [ ] 993. Minimum cost to hire k workers.
- [ ] 994. Swim in rising water.
- [ ] 995. Cheapest flights within k stops.
- [ ] 996. Network delay time.
- [ ] 997. Find the city with smallest number of neighbors.
- [ ] 998. Critical connections in network.
- [ ] 999. Accounts merge.
- [ ] 1000. Optimize water distribution in village.

---

## Study Tips for DSA Mastery

### Daily Practice Strategy
1. **Consistency is key** - Solve 5-10 problems daily
2. **Follow patterns** - Group similar problems together
3. **Time yourself** - Practice under interview conditions (45 min per problem)
4. **Review regularly** - Revisit problems after 1 week, 1 month

### Problem-Solving Approach
1. **Understand** - Read the problem 2-3 times
2. **Examples** - Work through examples manually
3. **Approach** - Think of brute force first, then optimize
4. **Pseudocode** - Write approach before coding
5. **Code** - Implement cleanly with good variable names
6. **Test** - Check edge cases (empty, single element, duplicates)
7. **Optimize** - Analyze time/space complexity

### Learning Resources
- **Books**: CLRS, Skiena's Algorithm Design Manual
- **Platforms**: LeetCode, Codeforces, HackerRank, GeeksforGeeks
- **Visualization**: VisuAlgo.net for algorithm animations
- **YouTube**: Abdul Bari, William Fiset, Tushar Roy

### Interview Preparation
- Master the top 100 LeetCode problems
- Practice explaining your thought process aloud
- Learn to recognize problem patterns
- Understand when to use which data structure
- Practice on a whiteboard or paper

### Common Patterns to Master
1. Two Pointers
2. Sliding Window
3. Fast & Slow Pointers
4. Merge Intervals
5. Cyclic Sort
6. In-place Reversal of LinkedList
7. Tree BFS/DFS
8. Two Heaps
9. Subsets
10. Modified Binary Search
11. Top K Elements
12. K-way Merge
13. Topological Sort
14. Union Find

Good luck with your DSA journey! ðŸš€ðŸ’»
